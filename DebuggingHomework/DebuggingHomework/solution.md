__The Problem__  
The issue with the provided code is that the MathProcessor class is a singleton and we are performing many non-threadsafe operations from each thread, using a list(which is not a thread-safe data structure).  
Of course this leads to many concurrency issues, one of which is a race condition in which if the start method is called on any thread (call it thread 1) after the for loop in the calculate method has started executing on any other thread (call this thread 2). This results in the operations list being empty while the loop bounds calculated using the size of operations on thread 2 will still be set at however many operations were previously in the operation list prior to thread 1 calling start, leading ultimately to an out of bounds access to the operations list.
__The Solution__  
The simplest solution is to have an instance of MathProcessor exist on every thread (simply done by removing the singleton pattern in Mathprocessor and instantiating a new instance in the getInstance method), this allows for reads and writes to be done on a seperate list for each thread, resulting in the desired behaviour.  
The drawback of this solution is that there is a memory cost associated with having many instances of the MathProcessor class.  
Instead, we could simply make the value and operations members in MathProcessor ThreadLocal(as has been done here) instead of creating a new instance of the entire MathProcessor class on every thread. This results in less memory cost than the solution of creating an instance of MathProcessor on every thread(it removes the cost associated with the object header for the MathProcessor class on every thread but the main thread.)  
__The Process__  
In order to solve the problem here I first ran '''mvn clean install''' to ensure that the issues described in the readme were occuring. After that was verified, I ran '''mvn clean install -e''' in order to get the full stacktrace.  
Reading the output you can find that an out of bounds error is happening in the calculate method. At this point I took the time to read over each of the classes to gain a basic understanding of what was occuring, as well as the unit tests to better understand the desired behavior and what was being done with threads(I assume they are being used here to simulate different users submitting requests via some sort of network).  
It became clear to me that having a singleton MathProcessor with many threads performing non-threadsafe operations on it was a problem. I tried commenting out the clear method in start first, and while this did result in fixing the specific bug described previously the test still did not pass. I then tried removing the concurrency from calculate using synchronized and using a threadsafe data structure instead of a list, these fixes of course did not work because all of the work is still being done to the same list from each thread, so even if there is no race condition the result will never be correct this way. All operations for a single initial value must be done in sequence followed by all operations for the next initial value, in order to achieve this I then tried removing the singleton pattern, which worked. I thought about how to optimize this solution and ended on making each of the member variables threadlocal to reduce memory footprint.  